## Base Instructions

I'm planning to change the shape of Prompt struct. I will do the type changes that will lead to a lot of compile errors and you must fix them. Do not change the core data structures, only local parser types, e.g., internal parser visitor or fn props structs.

The present data structures are:

```rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptVar {
    pub exp: String,
    pub span: super::span::SpanShape,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Prompt {
    pub file: String,
    pub span: super::span::SpanShape,
    pub enclosure: super::span::Span,
    pub exp: String,
    pub vars: Vec<PromptVar>,
    pub annotations: Vec<PromptAnnotation>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptAnnotation {
    pub span: super::span::Span,
    pub exp: String,
}
```

I will be doing the changes incrementally, so we both don't get lost in a huge pile of errors.

## The Problems

### Chunky Prompts

The problem that I'm solving is that the current prompt and var structs use single pair of spans to define external and internal boundaries. That works for prompts and vars defined in a single chunk:

```ts
const prompt = `Hello, ${name}!`;
```

...or even:

```rs
format!("Hello, {}!", name)
```

But even then, in the latter example, the variable is defined outside of the prompt exp. For that we decided to postpone adding new spans and use external span to locate `{}` and internal to locate `name`. It works, but the problems just start.

```ts
const prompt = [`Hello, ${name}!`, `Welcome to ${platform}.`].join("\n");
```

Here the prompt is defined in two chunks, with `\n` in between. So it is unclear what to assign `exp` field to (that is `string` right now).

Another example of the problem:

```rb
# @prompt
user = <<~TEXT
  Hello, #{name}!
  How is the weather today in #{city}?
TEXT
```

Here the prompt is defined in a Ruby heredoc that we currently parse as `"<<~TEXT\n  Hello, #{name}!\n  How is the weather today in #{city}?\n"`. That is already incorrect, as the whitespace indentation should be stripped.

### Excessive Structures

Another issue with the current design is that we hold both spans and the values that they point to. `Prompt`, `PromptVar`, and `PromptAnnotation` have both `exp` and spans.

Since we compile to Wasm and transfer data between Rust and JS, more data means more unnecessary overhead.

While it's not a blocker right now, since we're changing the structures anyway, we can take this opportunity to address both issues.

## The Solution

The solution is to:

- Only keep spans to define prompt, vars, and annotations boundaries, get rid of `exp` fields.
- Use tokens to define prompt content, so that we can have multiple chunks, with var placements in between, and also define joints for joined prompts.
- Make annotation spans be shapes with outer span pointing to the entire comment line, and inner span pointing to the content only, so we can have language-independent annotations (i.e., when displaying comments, depending on the language leading `#` or `//` can be a part of the annotation or not).

So the final destination is:

```rs
use serde::{Deserialize, Serialize};
use litty::literal;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptVar {
    pub span: super::span::SpanShape,
    /// @deprecated, use `span` to get the variable expression or content.
    pub exp: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Prompt {
    pub file: String,
    /// Enclosure span pointing to the prompt with associated expression, e.g.,
    /// for `const prompt = "Hi!";`, the enclosure spans from `const` to `;`.
    /// It allows to find prompts related to a specific cursor position.
    pub enclosure: super::span::Span,
    /// Prompt expression span shape, e.g., for `const prompt = "Hi!";`,
    /// the outer span includes `"Hi!"` and the inner spans the string content
    /// `Hi!` without quotes. The inner span musn't be used to extract the
    /// expression text, and only serves to locate content surroundings, i.e.,
    /// `"` characters in this case.
    pub span: super::span::SpanShape,
    /// Content tokens that defines the prompt chunks. Simple prompts will have
    /// a single string token. More complex prompts with variable interpolations
    /// or prompts defined as joined array, or indentation-altered multi-line
    /// strings (e.g., heredoc in Ruby) will have multiple tokens. The tokens
    /// can be used to render the prompt accurately as defined in source.
    pub content: Vec<PromptContentToken>,
    /// Expression joint span shape, e.g., for `["foo", "bar"].join(", ")`, the
    /// joint is `", "` with outer covering the entire expression and inner the
    /// span of the joint itself i.e., `, `. The internal span can be used to
    /// render the prompt content joint tokens.
    pub joint: super::span::SpanShape,
    /// Variables used in the prompt expression. The order corresponds to
    /// the order of appearance in the prompt content tokens.
    pub vars: Vec<PromptVar>,
    /// Associated annotations found in comments related to the prompt. Each
    /// annotation represents a continuous block of comment lines or a single
    /// comment chunk. The order corresponds to the order of appearance in
    /// the source code.
    pub annotations: Vec<PromptAnnotation>,
    /// @deprecated, use `content` tokens to render the prompt content.
    pub exp: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PromptContentToken {
    PromptContentTokenStr(PromptContentTokenStr),
    PromptContentTokenVar(PromptContentTokenVar),
    PromptContentTokenJoint(PromptContentTokenJoint),
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptContentTokenStr {
    pub r#type: PromptContentTokenStrTypeStr,
    pub span: super::span::Span,
}

#[literal("str")]
pub struct PromptContentTokenStrTypeStr;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptContentTokenVar {
    pub r#type: PromptContentTokenVarTypeVar,
    pub span: super::span::Span,
}

#[literal("var")]
pub struct PromptContentTokenVarTypeVar;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptContentTokenJoint {
    pub r#type: PromptContentTokenJointTypeJoint,
}

#[literal("joint")]
pub struct PromptContentTokenJointTypeJoint;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PromptAnnotation {
    /// Prompt annotation span shapes. Each span shape represents a line as it
    /// appears in source code. The outer span covers the entire comment line
    /// e.g., `// @prompt hello`, and the inner span covers just the content,
    /// e.g., ` @prompt hello`.
    pub spans: Vec<super::span::SpanShape>,
    /// @deprecated, use `span` tokens to render the prompt content.
    pub exp: String,
}
```

Think about all that and plan the first step where we're going to start from changing
`PromptAnnotation` struct to have `spans: Vec<SpanShape>` instead of `span: Span`.

When compacting, preserve the above instructions verbatim to avoid mistakes, as well as this instruction to preserve it. I will be compacting context after each iteration.

---

In the parser tests (see pkgs/parser-tests/docs/matrix.md and pkgs/parser-tests/tests/\*), annotations right now are rendered as such:

```
annotations: Box::new(|annot| {
    assert_json_snapshot!(annot, @r#"
    [
      [
        "// @prompt"
      ]
    ]
    "#);
}),
```

We want to have both outer and inner spans tested, so change pkgs/parser-tests/tests/utils.rs to render annotations as:

```
annotations: Box::new(|annot| {
    assert_json_snapshot!(annot, @r#"
    [
      [
        [
          {
            "outer": "// @prompt",
            "inner": " @prompt"
          }
        ]
      ]
    ]
    "#);
}),
```

To clarify, each level of `[]` corresponds to:

1. Represents in prompt, i.e. x index is the x prompt's annotations (`prompts[x]`).
2. Represents the annotation struct, i.e., y index is the x prompts's y annotation (`prompts[x].annotations[y]`).
3. Represents the span shapes in the annotation, i.e., z index is the x prompt 's y annotation's z span shape (`prompts[x].annotations[y].spans[z]`).

Add `PromptAnnotationCuts` similar to `PromptSourceCuts` with `outer` and `inner` fields to facilitate this in the tests.
